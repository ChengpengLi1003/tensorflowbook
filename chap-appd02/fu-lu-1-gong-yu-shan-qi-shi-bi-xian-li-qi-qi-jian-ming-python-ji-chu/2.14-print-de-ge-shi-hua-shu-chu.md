# 2.14 print的格式化输出

下图中展示了一些print的字符串格式化符号：

![&#x56FE;2-72](blob:https://minghuiwu.gitbook.io/fcbf844e-d94e-452a-99e3-aa8a5b65e626)

除了上述的这些，我们还有一些格式化操作符辅助指令：

![&#x56FE;2-73](blob:https://minghuiwu.gitbook.io/3b4490d8-4ee4-432c-9e2b-55a2930caadd)

下面我们来看一些具体的例子：

第一条语句中就是字符A，第二条语句中的虽然我们给出的值是65，但是它会被当成某一个字符的ASCII码，在这里呢，65表示的是大写的A，“%c”代表按照一个字符去输出，因此两条语句输出的值都是A：

![&#x56FE;2-74](../../.gitbook/assets/image%20%28113%29.png)

![&#x56FE;2-75](../../.gitbook/assets/image%20%2828%29.png)

![&#x56FE;2-76](../../.gitbook/assets/image%20%288%29.png)

![&#x56FE;2-77](../../.gitbook/assets/image%20%2862%29.png)

单纯的输出八进制或十六进制数我们是看不出来的，因此我们可以在前面格式的部分多加上一个“\#”，这样输出的时候可以更直观的分辨它是八进制、十进制还是十六进制数了。

![&#x56FE;2-78](../../.gitbook/assets/image%20%2869%29.png)

![&#x56FE;2-79](../../.gitbook/assets/image%20%28103%29.png)

“%f”如果没有指定小数点后的精度，它的默认精度是6位的：

![&#x56FE;2-80](../../.gitbook/assets/image%20%2837%29.png)

![&#x56FE;2-81](../../.gitbook/assets/image%20%28192%29.png)

当然还有一种更方便的方法是用“%g”，它会自动根据后面数字的大小决定它到底要输出多少，但是它所能表示的精度也是有限的：

![&#x56FE;2-82](../../.gitbook/assets/image%20%281%29.png)

下图的例子中，如果它本身的宽度就大于指定的值，那么就原样输出；如果小于指定的值，就会在前面补上空格（是右对齐的）：

![&#x56FE;2-83](../../.gitbook/assets/image%20%2839%29.png)

如果想要左对齐就要在前面加上“-”：

![&#x56FE;2-84](../../.gitbook/assets/image%20%289%29.png)

如果想要在正数前面显示正号就要在前面加上正号，如果是负数，当然显示的还是负号：

![&#x56FE;2-85](../../.gitbook/assets/image%20%2861%29.png)

下图中，后面元组中的5就代表了星号所在位置的数，也就是说对pi保留5位小数的精度：

![&#x56FE;2-86](../../.gitbook/assets/image%20%28124%29.png)

如果想要通过变量来填充格式控制字符串，那么可以使用运算符（%）和一个元组，在目标字符串中从左至右使用%来指代变量的位置。

比如下图中，元组中的第一个元素填充了%s的位置，而第二个元素填充了%.2f的位置（它的位置和元组中的顺序是一一对应的，如果类型不匹配将会报错）：

![&#x56FE;2-87](../../.gitbook/assets/image%20%2860%29.png)

我们也可以使用字典来对应填充：

![&#x56FE;2-88](../../.gitbook/assets/image%20%287%29.png)

