# 附录2 工欲善其事必先利其器：简明Python基础2

### &gt; Python的行

Python中没有强制的语句终止字符。

Python语句中一般以新行（换行）作为语句的结束符。

下图中，我们命名了三个名称非常长的变量并赋了初值，然后做了一个三个变量的相加，但是这条语句写在同一行中会非常长，不方便看也不美观。

![](blob:https://minghuiwu.gitbook.io/f36586ff-ed45-49b0-88ed-0cc712a87bdb)

但是直接把一条长语句从中间断开成多行是不可行的（第一行的加号后面有换行符，默认这条语句已经结束了，但是实际上这是一条不完整的语句）：

![](blob:https://minghuiwu.gitbook.io/2e601027-92da-4aed-8217-eeebb161d90e)

如果想要不报错，可以使用反斜杠“\”把一行的语句分为多行显示（这个反斜杠就起到了多行之间的连接作用，相当于这条语句写在了很长的一行）：

![](blob:https://minghuiwu.gitbook.io/d86b27ca-a793-478a-bc1d-187540b0f596)

语句中包含“\[\]”，“{}”，“\(\)”，中间换行就不需要使用多行连接符：

![](blob:https://minghuiwu.gitbook.io/11d60d10-ea55-4f8a-903d-0892d3013f03)

### \*\*\*\*

### **&gt; 流程控制**

任何一门语言（当然也包括Python），它的程序结构都可以归纳为三种基本结构：顺序、条件（选择、分支）、循环。

![](blob:https://minghuiwu.gitbook.io/967dde83-6292-4b69-82fc-fc1c2064463a)

#### 

#### &gt; 条件语句

条件语句是用if这个关键词来标识的。

![](blob:https://minghuiwu.gitbook.io/1215a792-d923-40b6-acbf-e43610dd8086)

在Python里，代码块是通过缩进来指示的。

缩进代表一个代码块的开始，逆缩进则表示一个代码块的结束。

在if语句中，条件表达式后面会以冒号“：”字符来表示声明的结束，具体满足条件要执行的语句块就在后面以一个缩进开始跟进。

比如下图这个语句，第一次输入的体重为100，满足了条件，输出了print中的语句。而第二次输入的体重为70，不满足条件，不会执行冒号后面的语句：

![](blob:https://minghuiwu.gitbook.io/2243fc54-c91f-4509-912a-d73070cc9694)

如果在python中不严格遵守缩进的格式会报错：

![](blob:https://minghuiwu.gitbook.io/2fd0aca7-75b8-4eb0-adca-5f959967e9c8)

图中第二行多缩进了几个空格就提示了缩进错误，因为两条串行的语句不能在不同的缩进层次。

当条件不满足的时候，我们也有语句块需要执行的话，就要用到if else语句：

![](blob:https://minghuiwu.gitbook.io/05031ef2-5b80-4a7c-aaed-d1e1fb4369f8)

我们把刚才的例子做了一个扩展，这样当if中的条件不满足时，它将会执行else后面的语句块：

![](blob:https://minghuiwu.gitbook.io/9e2b791f-dcfe-4e56-b117-f0b94ee994e9)

有的时候一个if else语句可能还不足以说明情况，我们就需要用到else if语句：

![](blob:https://minghuiwu.gitbook.io/7d5aa8a5-351e-4d61-946e-274bfd2773b7)

我们来看一个计算BMI指数的例子：

![](blob:https://minghuiwu.gitbook.io/3c19339e-5ee3-40bb-88ed-f37f5057002b)

![](blob:https://minghuiwu.gitbook.io/8e617e17-3c0d-4e26-aa8c-d4fcccafd9bd)

![](blob:https://minghuiwu.gitbook.io/ea0de719-60c0-4f87-be71-5470b279908c)

通过else if语句，我们完成了有三个分支选项的程序。如果情况更加复杂的话，我们也可以嵌套更多的else if语句。



#### &gt; 循环语句

Python提供了while循环和for循环。

循环语句允许执行一条语句或者语句块多次。

#### 

#### while循环语句：

![](blob:https://minghuiwu.gitbook.io/8a2aef40-3998-4cb9-8d86-95eac1a03b53)

下面我们来看一个具体的实例：

![](blob:https://minghuiwu.gitbook.io/9f73fb3f-f735-464a-8233-1b69ed200239)

这个程序中的count相当于一个计数工具，去统计6总共出现的次数**。**

在这个while循环中，我们通过对10取余的方法来逐位判断它是否等于6，如果相等，count就加一，每判断完一次就把末位数字除掉，然后在剩下的数字中继续统计6的个数，直到所有的数字都被判断完毕，这时num=0，不满足循环条件，程序结束。

#### 

#### for循环语句：

![](blob:https://minghuiwu.gitbook.io/4032814b-c1ee-4ebd-9d54-8fa0f754aa48)

图中的序列可以是一个列表也可以是一个集合。

它本质上就是把这个序列里面的每一个元素提取出来赋给循环变量，当这个序列被遍历完，也就是每一个元素都赋给循环变量然后去执行循环体，才会执行下一条语句。

刚刚用while循环实现的例子我们也可以用for循环来编写：

![](blob:https://minghuiwu.gitbook.io/fb832cb6-25ab-45c5-b9ce-e9c17b0aedd8)

图中的digit是一个循环变量，序列是转换成字符串后的2的100次方**。**

我们前面提过，字符串就是一个特殊的列表，每个字符串的元素都相当于列表中的一项，它执行的时候就是把列表里的每一项都赋值给digit，如果digit等于字符串6，count就加一。当这个循环结束的时候，也就意味着2的100次方这个长整数的每一位都去做了一遍这个if的测试，得到的结果跟while循环的结果是一致的。

在讲for循环的时候，还有一个用法，就是用for和range来枚举列表中的元素。

通过下图我们可以看到，它从0开始总共输出了10个数字（不包括10本身）：

![](blob:https://minghuiwu.gitbook.io/6b80567f-36cb-48dd-b430-9f00f9b8dd7b)

还有一种做法是指定上限和下限的区间（同样不包括10）：

![](blob:https://minghuiwu.gitbook.io/c69f616e-a556-41b6-beb7-7777d4a42053)



### &gt; 列表推导式

列表推导式（List Comprehension）提供了一个创建和操作列表的有力工具。

列表推导式由一个表达式以及紧跟着这个表达式的for语句构成，for语句还可以跟0个或多个if或for语句。

我们可以看到下面这个例子：

![](blob:https://minghuiwu.gitbook.io/63b89d30-f0cf-4d7b-a77a-f2f356e61c5b)

它先从lst1里面取出第一个数字分别与lst2里面的每个数字相乘，得到3个值，再从lst1中取出第二个数字分别与lst2里面的每个数字相乘，又得到3个值，依此类推，最终得到了9个值。它本质上是个双重循环。

数值判断还可以链接使用，例如1&lt;x&lt;3可以判断变量x是否在1到3之间。这是Python所有的特性，C语言中是不支持的。

比如下图中，lst1列表中的元素是1、2、3，因此满足在1到4之间条件的元素只有2和3:

![](blob:https://minghuiwu.gitbook.io/4ec9323a-4f99-4cf2-9ff2-1d7353dad5c5)



### &gt; 循环嵌套（多重循环）

这里有一个非常经典的例子——九九乘法表：

![](blob:https://minghuiwu.gitbook.io/6ae21523-3a7d-4ff4-adb8-06fbfe51cfe9)

for i in range\(1,10\)就说明它实际上有9个元素，会被执行9次。第一次会把1赋值给i，第二次把2赋值给i，一直到9。

在它循环体语句中的第一条语句依旧是for循环，此时形成了一个循环嵌套，它的循环变量是j，它的上限是i+1，而这个i就是外层循环中的循环变量i。当i等于1时，它的range就是（1，2），也就是说下面的循环体语句被执行一遍。

当执行完里面的循环后，还有一句“print（）”，看似没有做任何的输出，但是它起到了一个换行的作用。然后再开始i=2时的循环，这时的内循环将会被执行两次。依此类推，最终打印出一个完整的九九乘法表。

### 

### &gt; break语句

Break语句用在while和for循环中，用来终止循环语句，即循环条件没有False或者序列还没有被完全递归完也会停止执行循环语句。

我们来看下面这个例子：

![](blob:https://minghuiwu.gitbook.io/b13c1854-f90c-4ba7-8c2e-74e7a4ebbff5)

2的100次方中其实是包含了多个9的，如果我们只是想找到第一个9，那么找到第一个之后后面就没有必要找下去了，所以我们就有必要把循环提前终止掉。

上图中的pos是一个记录位置的值，初始化为0。然后我们逐位判断，如果这位数字等于9就break，也就是提前跳出循环，这时pos所指向的位置就是当前数字9的位置。



如果有多重循环的话，break语句将停止执行的仅仅是本层的循环，并不是跳出整个的循环。

下图是求2到100间素数的例子：

![](blob:https://minghuiwu.gitbook.io/40acefc1-dd5f-4c59-8447-8e0dbd45d21f)

我们设了一个标记位flag，初始化为0。

如果i%j等于0，说明i能够整除j，i并不是素数，这时把标记位置为1并break退出循环，因为已经找到了能被它整除的数，就说明它不可能是素数了。然后我们再来判断flag，如果flag等于0，就说明没有任何一个数字可以被它整除，那么它就是一个素数。

### 

### &gt; continue语句

continue语句是用来跳过当前循环的剩余语句，然后提前进行下一轮循环。

比如下面这个例子：

![](blob:https://minghuiwu.gitbook.io/063bdfa9-9756-4964-bd3e-b4bf9cc92b28)

我们先设了一个变量without9，它的初始值是一个空的字符串。

然后我们逐位判断，如果是9的话，就就会跳过下面的“without9 += digit”这条语句，如果不是9的话，这个without9这个字符串就会加上当前循环变量的数字变成一个新的字符串。因此，当程序结束的时候，得到的就是删除9之后的字符串。

### 

### &gt; pass语句

pass语句是空语句，它是为了保持程序结构的完整性，一般用做占位语句。

我们还是用刚刚这个例子：

![](blob:https://minghuiwu.gitbook.io/741885b2-e44f-4609-b3b2-caa83e624203)

在这个程序中，我们可以用pass来代替continue，然后在下面多加上一个else语句。在刚刚的程序中，“without9 += digit”这条语句和if语句是平行结构，而在现在这个程序中是if else语句，也就是两者选其一的结构：当这个数字为9就不加上，如果不是9就加上去。两个程序实现了一样的结果。



### &gt; 函数

函数是组织好的、可重复使用的、用来实现单一或者相关联功能的代码段。

函数能提高应用的模块性和代码的重复利用率。

Python提供了许多内建函数，比如print（）

开发者也可以自己创建函数，这被叫做用户自定义函数。

函数定义语法如下：

![](blob:https://minghuiwu.gitbook.io/a9b39f90-c42d-433e-a21f-6b7e8fe294af)

函数通过“def”关键字进行声明，后接函数标识符名称和圆括号“（）”。

任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。

“函数\_文档字符串”是一个可选项，起到一个帮助文档的作用。

return\[表达式\]结束函数，选择性地返回一个值给调用方。

不带表达式的return相当于返回None。



下面我们定义了一个求阶乘的函数：

![](blob:https://minghuiwu.gitbook.io/e3a919b8-e7da-4455-b2e7-3a3a0fc4a8bb)

在这里我们通过def这个关键词进行声明，后面是函数的名称fact，括号中的n是参数（不需要指定数据类型），然后是一个冒号“：”，下面是函数体，result是函数内部的局部变量，初始值为1，然后是一个for循环，由于range的上限是取不到的，所以1到n的阶乘要写成range（1，n+1），最后返回的result就是n阶乘的值。

定义好了之后，我们调用这个函数去求5的阶乘，就可以写成“fact（5）”，得到的结果是120。我们也可以把括号内的数字改成其他数字去计算其他数字的阶乘。

![](blob:https://minghuiwu.gitbook.io/5953efed-a352-4822-8cce-a3d4707137d5)

下面我们来看一个更加复杂的例子：

![](blob:https://minghuiwu.gitbook.io/81b3753e-588d-4941-9177-c321e6f022fb)

这里我们有一个item变量来保存阶乘的值，由于我们刚刚已经定义了一个求阶乘的函数，所以在这里就可以直接调用。

之后就是一个格式化输出。因为我们需要每两个换一行，所以在最后我们做了一个判断，如果这个i取余2等于1的话，我们就换行，从而实现了这个程序的要求。

虽然它实现的是一个相对复杂的功能，但是代码非常的清晰简短，这是因为我们在之前已经定义了fact函数。如果有错误需要修改，也会相对比较方便。



可选参数以集合的方式出现在函数声明中并紧跟着必选参数，可选参数可以在函数声明中被赋予一个默认值。已命名的参数需要赋值。

函数第一行语句可以选择性地使用文档字符串——用于存放函数说明。

函数可以返回一个元组（使用元组拆包可以有效返回多个值）。

下面来看一个例子：

![](blob:https://minghuiwu.gitbook.io/1af1ffc2-da17-4a9d-801b-9a6b550c4c4d)

我们定义了一个fun\_example函数，它有三个参数：第一个参数是一个列表型参数，第二、三个参数都赋了初值，是可选参数。这个函数的作用是在listp函数中添加一项“A new item”，intp的值加一。最后返回这三个参数。

接下来我们调用了这个函数。我们先定义了第一个参数和第二个参数的值，然后它们作为参数代入到函数中，由于第三个参数没有写，所以在定义中的初始值就是它的值：

![](blob:https://minghuiwu.gitbook.io/7b0ba7fa-c09e-4c31-8a42-ab98c1befea7)

那么我们如何对这个返回的元组进行拆包呢？

通过下图的方式我们就可以做到拆包啦：

![](blob:https://minghuiwu.gitbook.io/fa5ad84e-b63e-4ec6-bc41-c6550a54f711)



### &gt; 全局变量与局部变量

全局变量在函数之外声明，不定义在某个函数内部。它的作用范围是从定义的这条语句开始直到整个程序结束。

局部变量在函数内容声明，它的作用范围也仅仅是在这个函数内部。

函数如果有参数的话，参数也是局部变量，不需要在函数内部重复定义。

全局变量可以不需要任何特殊的声明即能读取，但如果想要修改全局变量的值，就必须在函数开始之处用global关键字进行声明，否则Python会将此变量按照新的局部变量处理。

比如下图这个例子：

![](blob:https://minghuiwu.gitbook.io/96348b42-fb47-47f8-aead-930097a0bbbc)

我们先给number赋初值为5，它并没有定义在某个函数内部，所以是个全局变量。然后我们定义了一个函数func1。

第一个5是调用func1（）所输出的，虽然在func1中并没有定义一个叫number的局部变量，但由于有一个同名的全局变量，所以全局变量的访问不管是在外面还是在某个函数内部都是有效的，输出的是5。后一句的print（number）指代的也是这个全局变量number，输出的也是5。



然后我们又定义了一个函数func2：

![](blob:https://minghuiwu.gitbook.io/709b6544-a630-4baf-927e-e2e6b01f3983)

在这个func2中，“number = 3”相当于在这个函数内部重新定义了一个局部变量number，并且输出了它的值，也就是3。一旦离开了这个函数，这个局部变量也就不复存在。所以里面的赋值不会影响外面的number，我们在最后输出的还是这个全局变量number，也就是5。



我们再来看第三个例子，我们定义了一个函数func3：

![](blob:https://minghuiwu.gitbook.io/463052f9-6d62-4970-91a2-f29804b37021)

在func3内部声明了一个全局变量number。global是一个关键词，说明这个number不是func3中的局部变量，而是外面的一个全局变量。这时给number重新赋值为3，并且输出它的值。所以在调用func3（）时，会影响外面的number，因此最后输出的时候，number的值为3。



最后我们再强调一点，函数参数也是局部变量，可以直接在函数内部使用，不需要在函数内部重复定义。

比如我们刚刚求n阶乘的例子：

![](blob:https://minghuiwu.gitbook.io/e3a919b8-e7da-4455-b2e7-3a3a0fc4a8bb)

我们并没有在函数中定义n，但是我们在for循环中用到了n。当我们调用fact（5）的时候，5就作为形式参数赋值给了n，n就起到局部变量的作用，它的作用范围也仅仅是在这个函数内部。



### &gt; 类

类（Class）是用来描述具有相同属性和方法的对象的集合。

它定义了该集合中每个对象所共有的属性和方法。

类是面向对象编程语言中最基本的概念。

对象是类的实例。

在Python中，我们使用class语句来创建一个新类，class之后为类的名称并以冒号“：”结尾。

具体格式如下：

![](blob:https://minghuiwu.gitbook.io/f4ff878a-2891-4991-942c-d4b4d235fb65)

和函数定义时类似，我们也可以在第一行放一个文档字符串，起到类的描述和帮助信息的作用。

class\_suite由类成员、方法、数据属性组成。

下面我们来看一个例子：

![](blob:https://minghuiwu.gitbook.io/ebfb3ab1-05ed-46b1-96e9-dbd6383cd1db)

我们定义了一个叫DeepLearner的类，我们通过class这个关键词进行定义，后面是类的名称DeepLearner，括号中的object是这个类所集成的对象类，然后是一个冒号“：”，第一行深红色的字就是我们前面提到的这个类的帮助文档。

下面定义了一个变量learnerCount，它的初始值为0。这个变量是这个类的属性，这个变量的值将在这个类中所有的实例之间共享。也就是说，不管你新建了多少个实例，它们访问到的是同一个变量。可以通过“类名.变量名”进行访问。

然后定义了一个\_\_init\_\_（）方法，它是一种特殊的方法，是类的构造函数或者说初始化方法，每当创建了这个类的实例时，就会自动地调用这个方法。

类的方法和普通的函数有一个很大的区别在于它的参数。所有类的第一个参数都是self，它所代表的就是这个实例本身。后面其他的参数可以根据你的需要来定义。

\_\_init\_\_（）方法中有三条语句。“self.name = name”代表在这个类中有一个叫name的属性，它的值是在构建一个新的实例的时候通过外面有一个叫name的参数把值传给它。下一条语句也是同样的道理。最后这条语句就是把learnerCount这个属性的值加一。

之后我们还定义了其他几个方法：getName（）就是返回这个实例name的属性值，getSchoolname（）就是返回这个实例schoolName的属性值，displayCount（）就是打印出learnerCount的信息，displayLearner（）就是打印出学习者的姓名以及学校名。



下面我们来看几个基于这个类的调用。

打印类的帮助文档信息：

![](blob:https://minghuiwu.gitbook.io/f6d2ccb2-1e32-48bb-9b0d-2eb08ed7d75c)

实例化和调用：

![](blob:https://minghuiwu.gitbook.io/f1d8d037-d276-40f2-8059-121e061429ad)

我们用DeepLearner.learnerCount得到的值为2，因为我们创建了两个实例。

之后我们分别用两个对象调用了displayCount（）方法，得到的结果是一样的，因为它们共享同一个learnerCount。

然后我们又分别调用了它们的getName（）和getSchoolname（）方法，打印出来的结果跟我们在实例化的时候所带进去的参数是一致的。

最后我们调用了它们的displayLearner（）方法，打印出来的就是根据我们定义好的参数所涉及的全部信息。



### &gt; 文件

Python针对文件的处理有很多内建的函数库可以调用。

比如下面这个例子：

![](blob:https://minghuiwu.gitbook.io/c3110eda-df4a-4ffb-9e8e-e5ee13433d09)

前面部分做的是写文件，后面部分做的是读文件。

它带有两个参数：第一个参数是文件名“test.txt”，第二个参数是文件的读写模式“wt”代表写文件，“rt”代表读文件。然后给它们分别取别名为out\_file和in\_file。

我们可以通过“out\_file.write（）”把要写到文件中的内容作为参数传进去，这样就可以完成一个写文件的操作。

我们可以通过“in\_file.read（）”来读取文件中的内容，把它赋给text，然后把text的内容打印出来。

那么这个test.txt文件写到哪里去了呢？它其实就在当前Python执行的目录底下。



### &gt; 异常

在编写代码的过程中并不是一帆风顺的，除了一些编写的错误，还有一些在运行输入时的除零异常等情况，所以我们需要去捕捉这些异常来保障程序不会崩溃。

Python中的异常由try-except\[exceptionname\]块处理。

下面我们用一个故意除零的例子来讲解一下异常：

![](blob:https://minghuiwu.gitbook.io/d2369b46-dc5a-46c4-a16d-a9a8097c5e4c)

我们定义了一个except\_function（）函数。在try中，我们所放的是想要执行的语句。在这里我们写了一个“10/0”的语句，这是一个故意除零的操作，会造成异常。而except就是去捕捉异常的模块。

如果发生了某一个异常，就把这个异常的具体名称放在except之后，然后就可以相应给出异常处理的代码。如果没有任何问题的话，就进入else语句。最后呢要注意：在finally里面的代码块，无论是否发生异常都会被执行。

异常的种类有很多，如果我们不知道具体的种类，可以用下图的写法来解决：

![](blob:https://minghuiwu.gitbook.io/7d737433-f28f-450e-9f04-ba0be4ac3ef7)



### &gt; 导入外部库

Python之所以那么流行，其中有很大一个原因就是在于Python有一个非常好的生态，这个生态也就是指有很多第三方提供了很多功能强大的外部库，这样就可以通过导入外部库让开发者很轻松地去实现很多强大的功能。

外部库可以使用import \[libname\]关键字来导入。

如果你确定只需要某一个库里的特殊的一些函数，也可以用from \[libname\] import \[funcname\]来导入所需要的函数。

我们来看下面这个例子：

![](blob:https://minghuiwu.gitbook.io/35639c09-ce28-46b6-a3f4-eacc4e8b58ae)

第一行我们导入了random这个库。第二行我们从time这个库中导入了time这个函数。第三行我们导入了numpy这个库并为了方便使用把它取别名为np。第四行我们导入了matplotlib里面的pyplot这个库并且也取了别名为plt（这个库在之后绘图的时候会用到）。

random.randint\(1,100\)表示在1到100之间产生一个整型的随机数，我们可以看到它产生的这个数字为77。



### &gt; 获取帮助信息

我们可能经常会遇到这种情况：在编程的时候不知道某个对象到底用了什么方法，也就没有办法直接去调用。这时候，我们就需要去查找帮助信息。

在Jupyter中提供了一种比较方便的联机搜索方法。

如果想知道一个对象是如何工作的，我们可以调用help（对象）

dir（）方法也会显示该对象的所有方法，而且还会显示其相应的文档

调用dir（）来显示该对象的所有方法：

![](blob:https://minghuiwu.gitbook.io/cb2b6086-a2f0-4b1b-8709-78a242a10033)

调用help（）会显示其文档：

![](blob:https://minghuiwu.gitbook.io/ae2d6e74-1169-4f67-8071-6056c9b83f1b)

相对来说会比刚才的dir（）更加详细一些。如果我们找到了某一个具体的方法，我们就可以直接去调用它。比如上图右下角的例子，我们可以看到返回的是它的负数形式。

在Jupyter中，实际上也提供了输入的提示：

![](blob:https://minghuiwu.gitbook.io/cfe33ad5-6e93-421b-b700-8214f2f2c27d)

比如刚刚的变量a，我们打了一个“a.”然后用tab键，就会出来许多它所相关的方法属性，可以在里面选择。



#### 最后希望通过这些简明的Python教程，可以帮助你在之后的学习中更好地应用和理解。

